package Dto;

import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;

import Controller.Server;

public class Clients {
	//서버에 들어오는 클라이언트의 클래스
	
	//1. 필드[소켓]
	public Socket socket;
	
	//2.생성자
	public Clients(Socket socket) {	
		this.socket = socket; 
		
		recive(); //서버와 연결된 클라이언트 객체가 생성될 때 받기 메소드 실행
	
	}

	
	//3. 서버로 메세지 받는 메소드
	public void recive() {

		//멀티스레드 [Thread 클래스 vs Runnable 인터페이스]
			//run 메소드를 필수적으로 구현해야함
		//인터페이스는 추상 메소드가 존재하기 때문에 구현필수[클래스에세 implements vs 익명객체]
		Runnable runnable = new Runnable() {
			
			@Override
			public void run() { //추상 메소드 구현
				//계속적으로 메시지 받는 상태
				
				
			try {
				while(true) {
					//1. 입력스트림 만들기
					InputStream inputStream = socket.getInputStream();

					//2. 바이트 배열선언[스트림은 바이트 단위]
					byte[] bytes = new byte[1000]; 
					
					//3. 입력스트림으로 바이트 읽어오기
					inputStream.read(bytes);
					
					//4. 바이트열 -> 문자열 변환
					String msg = new String(bytes);
					
					//*서버가 받은 메시지를 현재 서버에 접속된 모든 클라이언트에게 받은 메시지 보내기
						//현재 접속된 클라이언트리스트 빼오기
					for( Clients client: Server.clientlist) {
						
						client.send( msg );
						//4번으로 보냄
						//받은 메시지를 ㅓㅅ버에 접속된 clientlist 모든 클라이언트에게 메시지 보냄
						
						
					}//for end
				}//while end
				
			} catch (Exception e) {		}
			
			} //run end
			
		}; //runnable end
		//멀티스레드 구현 끝
		
		
		//해당 멀티스레드를 스레드풀에 넣어주기
		Server.threadpool.submit(runnable);
		
		
		
	} //recive end
		
	
	
	
	//4. 서버가 메세지 보는 메소드
		//실행조건 : 서버가 메시지를 받았을 때
	
	public void send (String msg) {
		
		Runnable runnable = new Runnable() {
			
			@Override
			public void run() {
				
				try {
					//1. 출력 스트림
					OutputStream outputStream = socket.getOutputStream();
					//2. 내보내기
					outputStream.write(msg.getBytes());
					
				} catch (Exception e) { }
			}
			
		}; //구현 끝
	
		Server.threadpool.submit(runnable);
	}
		
	

} // class end
