package Day14;

public class day14_3_메소드 { //day14_3_컨트롤러

	//메소드 = 함수
		//1. 인수o반환o
	//메소드 호출 방법 : 객체, static 중 1개 사용
	
	//1. 객체
	day14_3_컨트롤러 컨트롤러객체 = new day14_3_컨트롤러(); //빈 객체 만들기
	컨트롤러객체.입차1("1234");
	
	//2. static
	day14_3_컨트롤러.입차2("1234");
	
	//둘 중 어느것이건 저장공간 필요

		//1. 인수o반환o
		//인수는 메소드 안으로 들어가는 데이터 [메소드 동일한 자료형으로 받음]
		//반환은 메소드 밖으로 나가는 데이터 [메소드 호출 후 반환 받음]
		//@줬으니 무조건 받는다
	
	boolean 결과 = day14_3_컨트롤러.입차2("1234");
		//메소드에 1234문자를 인수로 보내고 메소드 실행 후 반환값을 결과 변수에 저장
	
	
		//2. 인수o반환x
	컨트롤러객체.출차("1234");
	//@주는게 없으니 저장하지 않아도 된다
	//메소드에 1234 문자를 인수로 보내고 메소드 실행 후 반환값이 없기 때문에 결과변수도 필요 x
	
	
		//3. 인수x반환o
	String 결과2 = 컨트롤러객체.매출();
	//@주는ㅇ게 없지만 받아야한다.
	//메소드에 인수 없이 보내고 메소드 실행 후 반환값을 결과2 변수에 저장한다.
	
	
		//4. 인수x반환x
	컨트롤러객체.차량리스트();
	//굳이 주고받을필요x 일반적인 실행만 함
	//실행 후 반환값을 인수 없이 보내고 메소드 실행 후 반환값이 없기 때문에 결과 변수x
	
	
	
	//@추가적으로 오버라이딩이 있음
	//메소드에서 @override 하는 거 : 동일한 메소드명, 동일한 인수의 메소드가 존재하면 재정의
	//상속받거나 인터페이스할때 오버라이드
			//동일한 인수의 슈퍼클래스or인터페이스에 존재할 경우 재정의.
			//그거 말고는 인터페이스할때 추상메소드 하는 것
		//슈퍼클래스 : 한마디로 메소드를 물려 받았는데 메소드를 재구현 하는 것
				//부모한테 집을 물려 받았으나 집을 리모델링 하는 느낌
		//인터페이스 : 추상 메소드에 구현하기 -> 동일한 메소드에 구현
				//익스텐스라고 함(연장. 상속이랑 비슷)
				//추상: 껍데기만 만드는 것. 내용물은 없음. ->집이라는 상상만 있음
						// 준다고 했으나 실제로 구현이 안 되어 있는것
				// implements : 구현하다[추상을 실제 구현하기]
	
	//추상메소드
		// 선언만 하므로 {}(ㄱ구현부) 없음
		//추상[ 상상 만들기 ] -> 클래스 내에서 실제 추상화를 구현하기
	//static, final
	
	
	
	
}
